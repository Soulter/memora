<template>
  <!-- Âø´ÈÄüÁ™óÂè£Ê®°Âºè -->
  <div class="quick-window" :class="{ 'mac-style': platform === 'darwin', 'win-style': platform === 'win32' }">
    <!-- ÈÄÄÂá∫ÊåâÈíÆ -->
    <button @click="closeQuickWindow" class="exit-button" title="ÈÄÄÂá∫">
      <svg class="exit-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>

    <!-- ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü -->
    <div class="main-content" :class="mainContentClass">
      <!-- ÈóÆÂÄôËØ≠ÔºåÂ±Ö‰∫éÊúÄ‰∏äÊñπ -->
      <div v-if="!capturedUrl && !statusMessage && !isProcessing && !showCaptureAnimation" class="greeting-section">
        <div class="greeting-content">
          <span class="greeting-emoji">üëã</span>
          <div class="greeting-texts">
            <div class="greeting-text">‰∏ãÂçàÂ•ΩÔºå</div>
            <div class="greeting-question">Êúâ‰ªÄ‰πàÊÉ≥Êî∂ÈõÜÁöÑÂêóÔºü</div>
          </div>
        </div>
      </div>

      <!-- Â±Ö‰∏≠ÂÆπÂô®ÔºåÂåÖÂê´ÈìæÊé•ÊòæÁ§∫„ÄÅËæìÂÖ•ÂíåÊçïËé∑ÊåâÈíÆ -->
      <div class="center-container" :class="centerContainerClass">
        <!-- ÊäìÂèñÂä®ÁîªÁïåÈù¢ -->
        <div v-if="showCaptureAnimation" class="capture-animation-section">
          <div class="animation-container">
            <!-- ‰∏ªË¶ÅÂä®ÁîªÂå∫Âüü -->
            <div class="main-animation">
              <div class="capture-loading-icon">
                <svg class="loading-animation" viewBox="0 0 100 100">
                  <circle class="loading-circle" cx="50" cy="50" r="45" fill="none" stroke="#3b82f6" stroke-width="4" stroke-linecap="round"/>
                </svg>
              </div>
              
              <!-- ÊµÆÂä®Á≤íÂ≠êÊïàÊûú -->
              <div class="particles">
                <div v-for="i in 12" :key="i" class="particle" :style="{ '--delay': `${i * 0.1}s`, '--angle': `${i * 30}deg` }"></div>
              </div>
              
              <!-- ËÑâÂÜ≤Ê≥¢Á∫π -->
              <div class="pulse-waves">
                <div class="pulse-wave"></div>
                <div class="pulse-wave"></div>
                <div class="pulse-wave"></div>
              </div>
            </div>
            
            <!-- ÊñáÂ≠óÂä®Áîª -->
            <div class="capture-text">
              <div class="text-line">
                <span class="text-char" v-for="(char, index) in 'Ê≠£Âú®ÊäìÂèñ'" :key="index" :style="{ '--delay': `${0.3 + index * 0.1}s` }">{{ char }}</span>
              </div>
              <div class="text-line">
                <span class="text-char" v-for="(char, index) in 'ËØ∑Á®çÂÄô'" :key="index" :style="{ '--delay': `${0.7 + index * 0.1}s` }">{{ char }}</span>
              </div>
            </div>
            
            <!-- ËøõÂ∫¶ÊåáÁ§∫Âô® -->
            <div class="progress-dots">
              <div class="dot" :class="{ 'active': true }" style="--delay: 1.0s"></div>
              <div class="dot" :class="{ 'active': true }" style="--delay: 1.1s"></div>
              <div class="dot" :class="{ 'active': true }" style="--delay: 1.2s"></div>
            </div>
          </div>
        </div>

        <!-- Ëß£ÊûêËøõÂ∫¶ÂíåÁªìÊûúÊòæÁ§∫Âå∫Âüü -->
        <div v-if="isProcessing || processedData" class="processing-section">
          <!-- Â§ÑÁêÜ‰∏≠Áä∂ÊÄÅ -->
          <div v-if="isProcessing" class="processing-state">
            <div class="url-info">
              <div class="url-header">
                <div class="status-indicator processing"></div>
                <span class="status-text">Ê≠£Âú®Ëß£ÊûêÈìæÊé•</span>
              </div>
              <div class="url-display">
                {{ capturedUrl }}
              </div>
            </div>

            <!-- ‰ºòÂåñÁöÑËøõÂ∫¶Ê≠•È™§ÊòæÁ§∫ -->
            <div class="progress-container">
              <div class="progress-steps">
                <div v-for="step in 5" :key="step" class="step-item" :class="{
                  'active': currentStep === step,
                  'completed': stepCompleted[step],
                  'pending': currentStep < step
                }">
                  <div class="step-indicator">
                    <div v-if="currentStep === step && !stepCompleted[step]" class="spinner"></div>
                    <svg v-else-if="stepCompleted[step]" class="check-icon" viewBox="0 0 20 20">
                      <path fill="currentColor"
                        d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" />
                    </svg>
                    <span v-else class="step-number">{{ step }}</span>
                  </div>
                  <span class="step-text">{{ stepTextMap[step] }}</span>
                </div>
              </div>

              <!-- ËøõÂ∫¶Êù° -->
              <div class="progress-bar">
                <div class="progress-fill"
                  :style="{ width: `${(Object.values(stepCompleted).filter(Boolean).length / 5) * 100}%` }"></div>
              </div>
            </div>
          </div>

          <!-- Â§ÑÁêÜÂÆåÊàêÁªìÊûú -->
          <div v-if="processedData && !isProcessing" class="processed-result">
                      <div class="result-header">
            <div class="url-section">
              <!-- URLÊòæÁ§∫/ÁºñËæëÂå∫Âüü -->
              <div v-if="!isEditingUrl" class="url-display-container">
                <div class="url-display">
                  {{ capturedUrl }}
                </div>
                <button @click="startEditingUrl" class="edit-btn" title="ÁºñËæëURL">
                  <svg class="edit-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                      d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                </button>
              </div>
              <!-- URLÁºñËæëÁä∂ÊÄÅ -->
              <div v-else class="url-edit-container">
                <input 
                  v-model="editingUrl" 
                  type="url" 
                  class="url-edit-input"
                  placeholder="ËæìÂÖ•URL..."
                  @keydown.enter="confirmAllChanges"
                  @keydown.esc="cancelEditing"
                />
                <div class="edit-actions">
                  <button @click="cancelEditing" class="cancel-btn" title="ÂèñÊ∂à">
                    <svg class="btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>

            <div class="result-content">
              <div v-if="processedData.category" class="info-card category-card">
                <div class="card-header">
                  <div class="card-title-group">
                    <svg class="card-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                    </svg>
                    <span class="card-title">ÂàÜÁ±ª</span>
                  </div>
                  <button v-if="!isEditingTags" @click="startEditingTags" class="edit-btn small" title="ÁºñËæëÊ†áÁ≠æ">
                    <svg class="edit-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                        d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>
                  </button>
                </div>
                <div class="category-content">
                  <span class="category-tag">{{ processedData.category }}</span>
                  <!-- Ê†áÁ≠æÊòæÁ§∫/ÁºñËæëÂå∫Âüü -->
                  <div v-if="!isEditingTags" class="tags-container">
                    <span v-if="processedData.tags && processedData.tags.length === 0" class="no-tags-hint">ÊöÇÊó†Ê†áÁ≠æ</span>
                    <span v-else-if="processedData.tags && processedData.tags.length" v-for="tag in processedData.tags" :key="tag" class="tag">{{ tag }}</span>
                  </div>
                  <div v-else-if="isEditingTags" class="tags-edit-container">
                    <div class="tags-edit-area">
                      <div class="editing-tags">
                        <span 
                          v-for="(tag, index) in editingTags" 
                          :key="index" 
                          class="editing-tag"
                        >
                          {{ tag }}
                          <button @click="removeTag(index)" class="remove-tag-btn" title="Âà†Èô§Ê†áÁ≠æ">
                            <svg class="remove-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                          </button>
                        </span>
                        <input 
                          ref="tagInput"
                          type="text" 
                          class="tag-input"
                          placeholder="ËæìÂÖ•Ê†áÁ≠æÂπ∂ÊåâÂõûËΩ¶..."
                          @keydown="handleTagKeydown($event)"
                          maxlength="20"
                        />
                      </div>
                    </div>
                    <div class="edit-actions">
                      <button @click="cancelEditing" class="cancel-btn" title="ÂèñÊ∂à">
                        <svg class="btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <div v-if="processedData.summary" class="info-card summary-card">
                <div class="card-header">
                  <div class="card-title-group">
                    <svg class="card-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    <span class="card-title">ÊëòË¶Å</span>
                  </div>
                  <button v-if="!isEditingSummary" @click="startEditingSummary" class="edit-btn small" title="ÁºñËæëÊëòË¶Å">
                    <svg class="edit-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                        d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>
                  </button>
                </div>
                <!-- ÊëòË¶ÅÊòæÁ§∫/ÁºñËæëÂå∫Âüü -->
                <div v-if="!isEditingSummary" class="summary-content">{{ processedData.summary }}</div>
                <div v-else class="summary-edit-container">
                  <textarea 
                    v-model="editingSummary" 
                    class="summary-edit-textarea"
                    placeholder="ËæìÂÖ•ÊëòË¶Å..."
                    @keydown.esc="cancelEditing"
                    rows="4"
                  ></textarea>
                  <div class="edit-actions">
                    <button @click="cancelEditing" class="cancel-btn" title="ÂèñÊ∂à">
                      <svg class="btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                </div>
              </div>
            </div>

            <div class="result-actions">
              <div v-if="showCompletionMessage" class="completion-message">
                <div class="status-indicator completed"></div>
                <span class="completion-text">Ëß£ÊûêÂÆåÊàê</span>
              </div>
              <button v-else @click="startNewCollection" class="action-btn primary-btn" :disabled="isUpdating">
                <svg v-if="!isUpdating" class="btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                </svg>
                <div v-else class="spinner btn-spinner"></div>
                {{ isEditingUrl || isEditingSummary || isEditingTags ? (isUpdating ? '‰øùÂ≠ò‰∏≠...' : 'Á°ÆËÆ§‰øÆÊîπ') : 'ÂºÄÂßãÊñ∞Êî∂ÈõÜ' }}
              </button>
            </div>
          </div>
        </div>

        <!-- ÊâãÂä®ËæìÂÖ•Âå∫Âüü -->
        <div v-if="!capturedUrl && !statusMessage && !isProcessing && !processedData && !showCaptureAnimation" class="input-section">
          <input v-model="manualUrl" type="url" class="url-input" placeholder="ËæìÂÖ•ÊàñÁ≤òË¥¥ÁΩëÈ°µÈìæÊé•..."
            @keydown.enter="useManualUrl" />
        </div>

        <!-- ÊçïËé∑ÊåâÈíÆÂå∫Âüü -->
        <div v-if="!isProcessing && !processedData && !showCaptureAnimation" class="capture-section">
          <!-- Detecting State -->
          <div v-if="isDetectingBrowser" class="detecting-state">
            <div class="spinner"></div>
            <span>Ê£ÄÊµã‰∏≠...</span>
          </div>

          <!-- Has Browser State -->
          <div v-else-if="hasBrowser" class="button-group">
            <button @click="captureEdgeUrl" :disabled="isCapturing" class="capture-btn" :class="{ 'disabled': isCapturing }">
              <Zap class="capture-icon" />
              <span>ÊäìÂèñ{{ getBrowserDisplayName(detectedBrowser) }}</span>
            </button>
          </div>
        </div>

        <!-- Êà™ÂõæÊåâÈíÆ -->
        <!-- <div style="display: flex; align-items: start; justify-content: start; width: 100%;">
          <button class="screenshot-btn" title="Êà™Âõæ">
            <svg class="screenshot-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
          </button>
        </div> -->

      </div>

      <!-- Áä∂ÊÄÅ‰ø°ÊÅØ -->
      <div v-if="statusMessage" class="status-message" :class="statusMessage.type">
        {{ statusMessage.text }}
      </div>

      <!-- ÂΩ©ËõãÊ∂àÊÅØ -->
      <div v-if="showEasterEgg" class="easter-egg-message">
        rnmÔºåËÄÅÂ≠êÈÉΩÊääF11Á¶ÅÁî®‰∫Ü‰Ω†ËøòÊåâ
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue'
import { Zap } from 'lucide-vue-next'

// Âø´ÈÄüÁ™óÂè£Áõ∏ÂÖ≥Áä∂ÊÄÅ
const capturedUrl = ref('')
const statusMessage = ref(null)
const manualUrl = ref('')
const isCapturing = ref(false)
const showCaptureAnimation = ref(false)

// ÊµèËßàÂô®Ê£ÄÊµãÁä∂ÊÄÅ
const detectedBrowser = ref('NONE')
const hasBrowser = ref(false)
const isDetectingBrowser = ref(true)

// Êìç‰ΩúÁ≥ªÁªüÊ£ÄÊµã
const platform = ref('win32')

// Êñ∞Â¢ûÔºöËß£ÊûêÁõ∏ÂÖ≥Áä∂ÊÄÅ
const isProcessing = ref(false)
const processedData = ref(null)
const currentStep = ref(0)
const stepCompleted = ref({
  1: false, // ÂàõÂª∫ÈõÜÂêà
  2: false, // Ëé∑ÂèñÂÜÖÂÆπ
  3: false, // ÂàÜÊûêÂàÜÁ±ª
  4: false, // ÁîüÊàêÊëòË¶Å
  5: false  // ÂÆåÊàêÁ¥¢Âºï
})

// Ëß£ÊûêÂÆåÊàêÊèêÁ§∫Áä∂ÊÄÅ
const showCompletionMessage = ref(false)

// Êñ∞Â¢ûÔºöÁºñËæëÁõ∏ÂÖ≥Áä∂ÊÄÅ
const isEditingUrl = ref(false)
const isEditingSummary = ref(false)
const isEditingTags = ref(false)
const editingUrl = ref('')
const editingSummary = ref('')
const editingTags = ref([])
const isUpdating = ref(false)

// Êñ∞Â¢ûÔºöÊµãËØïÂêéÁ´ØËøûÊé•
const isTesting = ref(false)

// ‰∫ã‰ª∂Êï∞ÊçÆ (ÁÆÄÂåñÁâàÔºåÂè™Áî®‰∫é‰øùÂ≠ò‰∫ã‰ª∂)
const events = ref([])

// ÂΩ©ËõãÔºöF11ÊåâÈîÆËÆ°Êï∞Âô®
const f11PressCount = ref(0)
const showEasterEgg = ref(false)

// Ê≠•È™§ÊñáÊú¨Êò†Â∞Ñ
const stepTextMap = {
  1: 'ÂàõÂª∫ÈõÜÂêà',
  2: 'Ëé∑ÂèñÂÜÖÂÆπ',
  3: 'ÂàÜÊûêÂàÜÁ±ª',
  4: 'ÁîüÊàêÊëòË¶Å',
  5: 'ÂÆåÊàêÁ¥¢Âºï'
}

// Âè™ÊúâÂàùÂßãÁä∂ÊÄÅÔºàÈóÆÂÄôËØ≠/ËæìÂÖ•ÔºâÊó∂padding-top‰∏∫50pxÔºåÂÖ∂‰Ωô‰∏∫0
const centerContainerClass = computed(() => {
  const isInitial = !capturedUrl.value && !statusMessage.value && !isProcessing.value && !processedData.value && !showCaptureAnimation.value
  return {
    'center-vertically': isInitial,
    'no-padding-top': !isInitial
  }
})

// main-contentÂä®ÊÄÅpadding
const mainContentClass = computed(() => {
  if (isProcessing.value || processedData.value) {
    return 'compact-padding';
  }
  return '';
});

const resetQuickWindowState = () => {
  capturedUrl.value = ''
  manualUrl.value = ''
  statusMessage.value = null
  isCapturing.value = false
  showCaptureAnimation.value = false
  isDetectingBrowser.value = true
  isProcessing.value = false
  processedData.value = null
  currentStep.value = 0
  isTesting.value = false
  showCompletionMessage.value = false
  // ÈáçÁΩÆÁºñËæëÁõ∏ÂÖ≥Áä∂ÊÄÅ
  isEditingUrl.value = false
  isEditingSummary.value = false
  isEditingTags.value = false
  editingUrl.value = ''
  editingSummary.value = ''
  editingTags.value = []
  isUpdating.value = false
  stepCompleted.value = {
    1: false,
    2: false,
    3: false,
    4: false,
    5: false
  }
}

const closeQuickWindow = async () => {
  resetQuickWindowState()
  if (window.electronAPI && window.electronAPI.invoke) {
    await window.electronAPI.invoke('hide-quick-window')
  }
}

// Êñ∞Â¢ûÔºöÊµãËØïÂêéÁ´ØËøûÊé•
const testBackendConnection = async () => {
  try {
    console.log('ÊµãËØïÂêéÁ´ØËøûÊé•...')
    const testResponse = await fetch('/api/v1/health', {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      }
    })

    console.log('ÊµãËØïËøûÊé•ÂìçÂ∫î:', {
      status: testResponse.status,
      statusText: testResponse.statusText
    })

    return testResponse.ok
  } catch (error) {
    console.error('ÂêéÁ´ØËøûÊé•ÊµãËØïÂ§±Ë¥•:', error)
    return false
  }
}

// Êñ∞Â¢ûÔºöË∞ÉÁî®APIËß£ÊûêÈìæÊé•
const processUrlWithAPI = async (url) => {
  try {
    console.log('=== ÂºÄÂßãÂ§ÑÁêÜURL ===')
    console.log('URL:', url)
    console.log('API Endpoint: /api/v1/collection/url')

    // ÂÖàÊµãËØïÂêéÁ´ØËøûÊé•
    const isBackendReachable = await testBackendConnection()
    if (!isBackendReachable) {
      throw new Error('Êó†Ê≥ïËøûÊé•Âà∞ÂêéÁ´ØÊúçÂä°Âô® (localhost:8000)')
    }

    // ÈáçÁΩÆÊäìÂèñÁä∂ÊÄÅÔºåÂºÄÂßãËß£Êûê
    isCapturing.value = false
    isProcessing.value = true
    currentStep.value = 0

    // ÈáçÁΩÆÊ≠•È™§Áä∂ÊÄÅ
    Object.keys(stepCompleted.value).forEach(key => {
      stepCompleted.value[key] = false
    })

    // Ê∑ªÂä†Êõ¥ËØ¶ÁªÜÁöÑËØ∑Ê±ÇÈÖçÁΩÆ
    const requestOptions = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'text/event-stream',
      },
      body: JSON.stringify({ url: url })
    }

    console.log('ËØ∑Ê±ÇÈÖçÁΩÆ:', requestOptions)
    console.log('ËØ∑Ê±Ç‰Ωì:', requestOptions.body)

    // Ê∑ªÂä†Ë∂ÖÊó∂Â§ÑÁêÜ
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 60000) // 60ÁßíË∂ÖÊó∂

    requestOptions.signal = controller.signal

    console.log('ÂèëÈÄÅfetchËØ∑Ê±Ç...')
    const response = await fetch('/api/v1/collection/url', requestOptions)

    clearTimeout(timeoutId)
    console.log('Êî∂Âà∞ÂìçÂ∫î:', {
      status: response.status,
      statusText: response.statusText,
      headers: Object.fromEntries(response.headers.entries())
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('HTTPÈîôËØØÂìçÂ∫î:', errorText)
      throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`)
    }

    if (!response.body) {
      throw new Error('ÂìçÂ∫î‰Ωì‰∏∫Á©∫')
    }

    console.log('ÂºÄÂßãËØªÂèñÊµÅÊï∞ÊçÆ...')
    const reader = response.body.getReader()
    const decoder = new TextDecoder()

    let buffer = ''
    const tempData = {
      collectionId: null,
      category: null,
      tags: null,
      summary: ''
    }

    let chunkCount = 0

    while (true) {
      const { done, value } = await reader.read()
      chunkCount++
      console.log(`ËØªÂèñÊï∞ÊçÆÂùó ${chunkCount}:`, { done, valueLength: value?.length })

      if (done) {
        console.log('ÊµÅÊï∞ÊçÆËØªÂèñÂÆåÊàê')
        break
      }

      buffer += decoder.decode(value, { stream: true })
      const lines = buffer.split('\n')
      buffer = lines.pop() || ''

      console.log(`Â§ÑÁêÜ ${lines.length} Ë°åÊï∞ÊçÆ`)

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const jsonStr = line.slice(6)
            console.log('Ëß£ÊûêSSEÊï∞ÊçÆ:', jsonStr)
            const data = JSON.parse(jsonStr)
            console.log('Ëß£ÊûêÁªìÊûú:', data)

            switch (data.type) {
              case 'collection_created':
                console.log('Êî∂Âà∞: collection_created')
                currentStep.value = 1
                stepCompleted.value[1] = true
                tempData.collectionId = data.data.id
                break

              case 'content_fetched':
                console.log('Êî∂Âà∞: content_fetched')
                currentStep.value = 2
                stepCompleted.value[2] = true
                break

              case 'category_analyzed':
                console.log('Êî∂Âà∞: category_analyzed')
                currentStep.value = 3
                stepCompleted.value[3] = true
                tempData.category = data.data.category
                tempData.tags = data.data.tags
                break

              case 'summary_chunk':
                console.log('Êî∂Âà∞: summary_chunk')
                if (currentStep.value < 4) {
                  currentStep.value = 4
                }
                tempData.summary += data.data.summary
                break

              case 'index_completed':
                console.log('Êî∂Âà∞: index_completed')
                currentStep.value = 5
                stepCompleted.value[4] = true
                stepCompleted.value[5] = true

                // Ê∏ÖÁêÜÊëòË¶ÅÊï∞ÊçÆ
                let cleanSummary = tempData.summary
                try {
                  // Â∞ùËØïËß£ÊûêJSONÊ†ºÂºèÁöÑÊëòË¶Å
                  const jsonMatch = cleanSummary.match(/\{[^}]*"summary":\s*"([^"]*)"[^}]*\}/)
                  if (jsonMatch && jsonMatch[1]) {
                    cleanSummary = jsonMatch[1]
                  } else {
                    // ÁßªÈô§JSONÊ†áËÆ∞Á¨¶Âè∑
                    cleanSummary = cleanSummary.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/^\{?\s*"?\s*/, '').replace(/\s*"?\s*\}?$/g, '')
                  }
                } catch (e) {
                  console.error('Ê∏ÖÁêÜÊëòË¶ÅÊó∂Âá∫Èîô:', e)
                }

                processedData.value = {
                  collectionId: tempData.collectionId,
                  category: tempData.category,
                  tags: tempData.tags,
                  summary: cleanSummary
                }

                console.log('Â§ÑÁêÜÂÆåÊàêÔºåÊúÄÁªàÊï∞ÊçÆ:', processedData.value)

                isProcessing.value = false
                showCompletionMessage.value = true

                setTimeout(() => {
                  showCompletionMessage.value = false
                }, 2000)
                break

              default:
                console.log('Êú™Áü•‰∫ã‰ª∂Á±ªÂûã:', data.type)
            }
          } catch (error) {
            console.error('Ëß£ÊûêSSEÊï∞ÊçÆÊó∂Âá∫Èîô:', error, 'ÂéüÂßãÊï∞ÊçÆ:', line)
          }
        }
      }
    }

    console.log('=== URLÂ§ÑÁêÜÂÆåÊàê ===')

  } catch (error) {
    console.error('=== Â§ÑÁêÜURLÊó∂Âá∫Èîô ===')
    console.error('ÈîôËØØÁ±ªÂûã:', error.name)
    console.error('ÈîôËØØÊ∂àÊÅØ:', error.message)
    console.error('ÈîôËØØÂ†ÜÊ†à:', error.stack)

    isProcessing.value = false
    currentStep.value = 0

    let errorMessage = 'Ëß£ÊûêÂ§±Ë¥•'

    if (error.name === 'AbortError') {
      errorMessage = 'ËØ∑Ê±ÇË∂ÖÊó∂ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•'
    } else if (error.message.includes('fetch')) {
      errorMessage = 'ÁΩëÁªúËøûÊé•Â§±Ë¥•ÔºåËØ∑Á°ÆËÆ§ÂêéÁ´ØÊúçÂä°ÊòØÂê¶ÂêØÂä®'
    } else if (error.message.includes('CORS')) {
      errorMessage = 'Ë∑®ÂüüËØ∑Ê±ÇË¢´ÈòªÊ≠¢'
    } else {
      errorMessage = `Ëß£ÊûêÂ§±Ë¥•: ${error.message}`
    }

    statusMessage.value = {
      type: 'error',
      text: errorMessage
    }

    setTimeout(() => {
      statusMessage.value = null
    }, 5000)
  }
}

// ‰øÆÊîπÔºöÊäìÂèñURLÂêéËá™Âä®Â§ÑÁêÜ
const captureEdgeUrl = async () => {
  if (isCapturing.value) return // Èò≤Ê≠¢ÈáçÂ§çÁÇπÂáª
  
  if (window.electronAPI && window.electronAPI.send) {
    window.electronAPI.send('capture-url-start')
  }

  try {
    // Á´ãÂç≥ÊòæÁ§∫Âä®ÁîªÂíåËÆæÁΩÆÊäìÂèñÁä∂ÊÄÅ
    isCapturing.value = true
    showCaptureAnimation.value = true
    statusMessage.value = null

    console.log('Starting URL capture for browser:', detectedBrowser.value)

    if (window.electronAPI && window.electronAPI.invoke) {
      const result = await window.electronAPI.invoke('capture-edge-url')

      if (result.success) {
        capturedUrl.value = result.url
        console.log('Successfully captured URL:', result.url)

        // Á≠âÂæÖÂä®ÁîªÊí≠ÊîæÂÆåÊàêÂêéÂºÄÂßãÂ§ÑÁêÜURLÔºàÂä®Áîª‰ªéÁÇπÂáªÂºÄÂßãËÆ°ÁÆóÔºåËøôÈáåÂÜçÁ≠â1.5ÁßíÔºâ
        setTimeout(() => {
          showCaptureAnimation.value = false
          processUrlWithAPI(result.url)
        }, 1500)

      } else {
        statusMessage.value = {
          type: 'error',
          text: result.error || 'Ëé∑ÂèñÂ§±Ë¥•'
        }
        console.log('URL capture failed:', result.error)
        setTimeout(() => {
          statusMessage.value = null
          isCapturing.value = false
        }, 3000)
      }
    } else {
      statusMessage.value = { type: 'error', text: 'API ‰∏çÂèØÁî®' }
      setTimeout(() => {
        statusMessage.value = null
        isCapturing.value = false
      }, 3000)
    }
  } catch (error) {
    console.error('Error capturing URL:', error)
    statusMessage.value = {
      type: 'error',
      text: 'Ëé∑ÂèñÈìæÊé•Êó∂Âá∫Èîô: ' + error.message
    }
    setTimeout(() => {
      statusMessage.value = null
      isCapturing.value = false
    }, 3000)
  } finally {
    if (window.electronAPI && window.electronAPI.send) {
      window.electronAPI.send('capture-url-end')
    }
  }
}

// Êñ∞Â¢ûÔºöËé∑ÂèñÈõÜÂêàÊ†áÁ≠æÁöÑAPIË∞ÉÁî®
const fetchCollectionTags = async (collectionId) => {
  try {
    console.log(`=== Ëé∑ÂèñÈõÜÂêàÊ†áÁ≠æ ===`)
    console.log('Collection ID:', collectionId)

    const response = await fetch(`/api/v1/collection/${collectionId}/tags`, {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      }
    })

    console.log('Ëé∑ÂèñÊ†áÁ≠æÂìçÂ∫î:', {
      status: response.status,
      statusText: response.statusText
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Ëé∑ÂèñÊ†áÁ≠æÂ§±Ë¥•:', errorText)
      throw new Error(`Ëé∑ÂèñÊ†áÁ≠æÂ§±Ë¥•: ${response.status} ${response.statusText}`)
    }

    const result = await response.json()
    console.log('Ëé∑ÂèñÊ†áÁ≠æÊàêÂäü:', result)
    return result.data.tags
  } catch (error) {
    console.error('Ëé∑ÂèñÈõÜÂêàÊ†áÁ≠æÂ§±Ë¥•:', error)
    statusMessage.value = {
      type: 'error',
      text: `Ëé∑ÂèñÊ†áÁ≠æÂ§±Ë¥•: ${error.message}`
    }
    setTimeout(() => {
      statusMessage.value = null
    }, 5000)
    return []
  }
}

// Êñ∞Â¢ûÔºöÊõ¥Êñ∞ÈõÜÂêàÊ†áÁ≠æÁöÑAPIË∞ÉÁî®
const updateCollectionTags = async (collectionId, tags) => {
  try {
    console.log(`=== Êõ¥Êñ∞ÈõÜÂêàÊ†áÁ≠æ ===`)
    console.log('Collection ID:', collectionId)
    console.log('Tags:', tags)

    const response = await fetch(`/api/v1/collection/${collectionId}/tags`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({ tags: tags })
    })

    console.log('Êõ¥Êñ∞Ê†áÁ≠æÂìçÂ∫î:', {
      status: response.status,
      statusText: response.statusText
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Êõ¥Êñ∞Ê†áÁ≠æÂ§±Ë¥•:', errorText)
      throw new Error(`Êõ¥Êñ∞Ê†áÁ≠æÂ§±Ë¥•: ${response.status} ${response.statusText}`)
    }

    const result = await response.json()
    console.log('Êõ¥Êñ∞Ê†áÁ≠æÊàêÂäü:', result)
    return result.data.tags
  } catch (error) {
    console.error('Êõ¥Êñ∞ÈõÜÂêàÊ†áÁ≠æÂ§±Ë¥•:', error)
    statusMessage.value = {
      type: 'error',
      text: `Êõ¥Êñ∞Ê†áÁ≠æÂ§±Ë¥•: ${error.message}`
    }
    setTimeout(() => {
      statusMessage.value = null
    }, 5000)
    return null
  }
}

// Êñ∞Â¢ûÔºöÊõ¥Êñ∞ÈõÜÂêàËØ¶ÊÉÖÁöÑAPIË∞ÉÁî®
const updateCollectionDetail = async (key, value) => {
  try {
    isUpdating.value = true
    console.log(`=== Êõ¥Êñ∞ÈõÜÂêàËØ¶ÊÉÖ ===`)
    console.log('Collection ID:', processedData.value.collectionId)
    console.log('Key:', key)
    console.log('Value:', value)

    const response = await fetch(`/api/v1/collection/${processedData.value.collectionId}/details/${key}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({ value: value })
    })

    console.log('Êõ¥Êñ∞ÂìçÂ∫î:', {
      status: response.status,
      statusText: response.statusText
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Êõ¥Êñ∞Â§±Ë¥•:', errorText)
      throw new Error(`Êõ¥Êñ∞Â§±Ë¥•: ${response.status} ${response.statusText}`)
    }

    const result = await response.json()
    console.log('Êõ¥Êñ∞ÊàêÂäü:', result)

    // Êõ¥Êñ∞Êú¨Âú∞Êï∞ÊçÆ
    if (key === 'url') {
      // ËøôÈáåÊàë‰ª¨‰∏çÊõ¥Êñ∞capturedUrlÔºåÂõ†‰∏∫ÈÇ£ÊòØÂéüÂßãÊäìÂèñÁöÑURL
      // processedData‰∏≠‰πü‰∏çÂåÖÂê´urlÂ≠óÊÆµÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØËÉΩÈúÄË¶ÅÊ∑ªÂä†‰∏Ä‰∏™ÊòæÁ§∫Áî®ÁöÑÂ≠óÊÆµ
    } else if (key === 'summary') {
      processedData.value.summary = value
    }

    return true
  } catch (error) {
    console.error('Êõ¥Êñ∞ÈõÜÂêàËØ¶ÊÉÖÂ§±Ë¥•:', error)
    statusMessage.value = {
      type: 'error',
      text: `Êõ¥Êñ∞Â§±Ë¥•: ${error.message}`
    }
    setTimeout(() => {
      statusMessage.value = null
    }, 5000)
    return false
  } finally {
    isUpdating.value = false
  }
}

// Êñ∞Â¢ûÔºöÂºÄÂßãÁºñËæëURL
const startEditingUrl = () => {
  isEditingUrl.value = true
  editingUrl.value = capturedUrl.value
}

// Êñ∞Â¢ûÔºöÂºÄÂßãÁºñËæëÊëòË¶Å
const startEditingSummary = () => {
  isEditingSummary.value = true
  editingSummary.value = processedData.value.summary
}

// Êñ∞Â¢ûÔºöÂºÄÂßãÁºñËæëÊ†áÁ≠æ
const startEditingTags = async () => {
  isEditingTags.value = true
  // Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊ†áÁ≠æÊï∞ÊçÆ
  const tags = await fetchCollectionTags(processedData.value.collectionId)
  editingTags.value = Array.isArray(tags) ? [...tags] : [] // ÂàõÂª∫ÂâØÊú¨‰ª•ÈÅøÂÖçÁõ¥Êé•‰øÆÊîπÂéüÊï∞ÊçÆ
}

// Êñ∞Â¢ûÔºöÂèñÊ∂àÁºñËæë
const cancelEditing = () => {
  isEditingUrl.value = false
  isEditingSummary.value = false
  isEditingTags.value = false
  editingUrl.value = ''
  editingSummary.value = ''
  editingTags.value = []
}

// Êñ∞Â¢ûÔºöÊ†áÁ≠æÁºñËæëÁõ∏ÂÖ≥ÂáΩÊï∞
const addNewTag = (tagText) => {
  if (tagText && tagText.trim() && !editingTags.value.includes(tagText.trim())) {
    editingTags.value.push(tagText.trim())
  }
}

const removeTag = (index) => {
  editingTags.value.splice(index, 1)
}

const handleTagKeydown = (event, inputRef) => {
  if (event.key === 'Enter' && event.target.value.trim()) {
    event.preventDefault()
    addNewTag(event.target.value)
    event.target.value = ''
  } else if (event.key === 'Backspace' && !event.target.value && editingTags.value.length > 0) {
    // ÂΩìËæìÂÖ•Ê°Ü‰∏∫Á©∫Êó∂ÊåâÈÄÄÊ†ºÈîÆÂà†Èô§ÊúÄÂêé‰∏Ä‰∏™Ê†áÁ≠æ
    removeTag(editingTags.value.length - 1)
  }
}

// Êñ∞Â¢ûÔºöÁ°ÆËÆ§ÊâÄÊúâ‰øÆÊîπ
const confirmAllChanges = async () => {
  let allSuccess = true

  // Êõ¥Êñ∞URLÔºàÂ¶ÇÊûúÊ≠£Âú®ÁºñËæë‰∏îÊúâÂèòÂåñÔºâ
  if (isEditingUrl.value && editingUrl.value !== capturedUrl.value) {
    const success = await updateCollectionDetail('url', editingUrl.value)
    if (success) {
      capturedUrl.value = editingUrl.value
    } else {
      allSuccess = false
    }
  }

  // Êõ¥Êñ∞ÊëòË¶ÅÔºàÂ¶ÇÊûúÊ≠£Âú®ÁºñËæë‰∏îÊúâÂèòÂåñÔºâ
  if (isEditingSummary.value && editingSummary.value !== processedData.value.summary) {
    const success = await updateCollectionDetail('summary', editingSummary.value)
    if (!success) {
      allSuccess = false
    }
  }

  // Êõ¥Êñ∞Ê†áÁ≠æÔºàÂ¶ÇÊûúÊ≠£Âú®ÁºñËæë‰∏îÊúâÂèòÂåñÔºâ
  if (isEditingTags.value) {
    const currentTags = processedData.value.tags || []
    const tagsChanged = JSON.stringify(editingTags.value.sort()) !== JSON.stringify(currentTags.sort())
    if (tagsChanged) {
      const updatedTags = await updateCollectionTags(processedData.value.collectionId, editingTags.value)
      if (updatedTags !== null) {
        processedData.value.tags = updatedTags
      } else {
        allSuccess = false
      }
    }
  }

  if (allSuccess) {
    // ÈÄÄÂá∫ÁºñËæëÊ®°Âºè
    cancelEditing()
    
    // ÊòæÁ§∫ÂÆåÊàêÊ∂àÊÅØÂπ∂Ëá™Âä®ÂÖ≥Èó≠Á™óÂè£
    showCompletionMessage.value = true
    statusMessage.value = {
      type: 'success',
      text: '‰øÆÊîπ‰øùÂ≠òÊàêÂäü'
    }
    
    setTimeout(() => {
      showCompletionMessage.value = false
      statusMessage.value = null
      // Ëá™Âä®ÂÖ≥Èó≠Á™óÂè£
      closeQuickWindow()
    }, 2000)
  }
}

// ‰øÆÊîπÔºöÂéüÊù•ÁöÑÁ°ÆËÆ§‰øÆÊîπÂáΩÊï∞
const startNewCollection = () => {
  // Â¶ÇÊûúÊúâ‰ªª‰ΩïÁºñËæëÁä∂ÊÄÅÔºåÂÖàÁ°ÆËÆ§‰øÆÊîπ
  if (isEditingUrl.value || isEditingSummary.value || isEditingTags.value) {
    confirmAllChanges()
  } else {
    resetQuickWindowState()
  }
}

// Êñ∞Â¢ûÔºöÊµãËØïÂêéÁ´ØËøûÊé•
const testConnection = async () => {
  try {
    isTesting.value = true
    console.log('=== ÊâãÂä®ÊµãËØïÂêéÁ´ØËøûÊé• ===')

    // ÊµãËØïÂü∫Êú¨ËøûÊé•
    const isReachable = await testBackendConnection()
    if (!isReachable) {
      statusMessage.value = {
        type: 'error',
        text: 'Êó†Ê≥ïËøûÊé•Âà∞ÂêéÁ´ØÊúçÂä°Âô® (localhost:8000)'
      }
      setTimeout(() => {
        statusMessage.value = null
      }, 5000)
      return
    }

    // ÊµãËØïAPIÁ´ØÁÇπ
    console.log('ÊµãËØïAPIÁ´ØÁÇπ...')
    const testResponse = await fetch('/api/v1/collection/url', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'text/event-stream'
      },
      body: JSON.stringify({ url: 'https://example.com' })
    })

    console.log('APIÊµãËØïÂìçÂ∫î:', {
      status: testResponse.status,
      statusText: testResponse.statusText,
      headers: Object.fromEntries(testResponse.headers.entries())
    })

    if (testResponse.ok) {
      statusMessage.value = {
        type: 'success',
        text: 'ÂêéÁ´ØËøûÊé•ÊµãËØïÊàêÂäüÔºÅ'
      }
    } else {
      const errorText = await testResponse.text()
      console.error('APIÊµãËØïÂ§±Ë¥•:', errorText)
      statusMessage.value = {
        type: 'error',
        text: `APIÊµãËØïÂ§±Ë¥•: ${testResponse.status} ${testResponse.statusText}`
      }
    }

    setTimeout(() => {
      statusMessage.value = null
    }, 3000)

  } catch (error) {
    console.error('ËøûÊé•ÊµãËØïÂ§±Ë¥•:', error)
    statusMessage.value = {
      type: 'error',
      text: `ËøûÊé•ÊµãËØïÂ§±Ë¥•: ${error.message}`
    }
    setTimeout(() => {
      statusMessage.value = null
    }, 5000)
  } finally {
    isTesting.value = false
  }
}

// ‰øÆÊîπÔºöÊâãÂä®ËæìÂÖ•URLÂêéËá™Âä®Â§ÑÁêÜ
const useManualUrl = () => {
  if (!manualUrl.value.trim()) return

  try {
    new URL(manualUrl.value)
    capturedUrl.value = manualUrl.value
    const url = manualUrl.value
    manualUrl.value = ''
    statusMessage.value = { type: 'success', text: 'ÈìæÊé•Â∑≤ËÆæÁΩÆ' }

    // Ëá™Âä®ÂºÄÂßãÂ§ÑÁêÜURL
    setTimeout(() => {
      statusMessage.value = null
      processUrlWithAPI(url)
    }, 1000)
  } catch (error) {
    statusMessage.value = { type: 'error', text: 'ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÁΩëÈ°µÈìæÊé•' }
    setTimeout(() => {
      statusMessage.value = null
    }, 2000)
  }
}

const detectBrowser = async () => {
  try {
    console.log('Re-starting browser detection from renderer...')
    isDetectingBrowser.value = true
    if (window.electronAPI && window.electronAPI.invoke) {
      const result = await window.electronAPI.invoke('detect-active-browser')
      console.log('Re-detection result:', result)
      isDetectingBrowser.value = false
      if (result.success) {
        detectedBrowser.value = result.browser
        hasBrowser.value = result.hasBrowser
        if (result.hasBrowser) {
          statusMessage.value = {
            type: 'success',
            text: `Âà∑Êñ∞ÊàêÂäü: ${getBrowserDisplayName(result.browser)}`
          }
        } else {
          statusMessage.value = { type: 'info', text: '‰ªçÊú™Ê£ÄÊµãÂà∞ÊµèËßàÂô®' }
        }
      } else {
        detectedBrowser.value = 'NONE'
        hasBrowser.value = false
        statusMessage.value = { type: 'error', text: 'Âà∑Êñ∞Ê£ÄÊµãÂ§±Ë¥•' }
      }
      setTimeout(() => {
        statusMessage.value = null
      }, 2000)
    }
  } catch (error) {
    console.error('Error re-detecting browser:', error)
    isDetectingBrowser.value = false
    detectedBrowser.value = 'NONE'
    hasBrowser.value = false
    statusMessage.value = { type: 'error', text: 'Âà∑Êñ∞Ê£ÄÊµãÂá∫Èîô' }
    setTimeout(() => {
      statusMessage.value = null
    }, 2000)
  }
}

const getBrowserDisplayName = (browser) => {
  const names = {
    'EDGE': 'Edge',
    'CHROME': 'Chrome',
    'FIREFOX': 'Firefox',
    'IE': 'IE',
    'OPERA': 'Opera',
    'BRAVE': 'Brave',
    'VIVALDI': 'Vivaldi',
    'UNKNOWN_BROWSER': 'Êú™Áü•ÊµèËßàÂô®',
    'NONE': 'Êó†ÊµèËßàÂô®'
  }
  return names[browser] || browser
}

onMounted(() => {
  // Ê£ÄÊµãÊìç‰ΩúÁ≥ªÁªü
  if (window.electronAPI && window.electronAPI.getPlatform) {
    platform.value = window.electronAPI.getPlatform()
    console.log('Detected platform:', platform.value)
  }

  if (window.electronAPI && window.electronAPI.on) {
    window.electronAPI.on('browser-detection-start', () => {
      console.log('Received browser-detection-start event')
      isDetectingBrowser.value = true
      hasBrowser.value = false
    })

    window.electronAPI.on('browser-detected', (result) => {
      console.log('Received browser-detected event:', result)
      isDetectingBrowser.value = false
      if (result && result.success) {
        detectedBrowser.value = result.browser
        hasBrowser.value = result.hasBrowser
      } else {
        detectedBrowser.value = 'NONE'
        hasBrowser.value = false
      }
    })
  }

  // ÁõëÂê¨F11‰∫ã‰ª∂ÔºåÂÆûÁé∞ÂΩ©Ëõã
  if (window.electronAPI && window.electronAPI.on) {
    window.electronAPI.on('f11-pressed', () => {
      console.log('F11 pressed! Count:', f11PressCount.value + 1) // Ë∞ÉËØïÊó•Âøó
      f11PressCount.value++

      if (f11PressCount.value >= 10) {
        console.log('Easter egg triggered!') // Ë∞ÉËØïÊó•Âøó
        showEasterEgg.value = true
        f11PressCount.value = 0 // ÈáçÁΩÆËÆ°Êï∞Âô®

        // 3ÁßíÂêéÈöêËóèÂΩ©Ëõã
        setTimeout(() => {
          showEasterEgg.value = false
        }, 3000)
      }
    })
  }
})
</script>

<style lang="scss" scoped>
  @import '../assets/QuickWindow.scss';
</style>
